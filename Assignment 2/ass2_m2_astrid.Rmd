---
title: "Assignment-2-m2"
author: "Astrid NÃ¸rgaard Fonager"
date: "2023-03-09"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
library(pacman)

pacman::p_load(tidyverse,
        here,
        posterior,
        cmdstanr,
        brms, tidybayes, future, purrr, furrr, prettydoc,
        tidyr,
        patchwork,
        ggpubr,
        gtools)
```

# FUNCTIONS

```{r agent functions}

# Random bot
random_agent <- function(bias = 0.7) {
  choice <- rbinom(1,1, bias)
  return(choice)
}

# Win-shift-lose-stay agent
win_shift_agent <- function(prev_choice, feedback, rule_following) {
  if (feedback == 0) { #lose stay
    if(prev_choice == 0) { 
      choice = rbinom(1, 1, (1-rule_following))}
    if(prev_choice == 1) { 
      choice = rbinom(1, 1, rule_following)}
      }
  else if (feedback == 1) { #win shift
    if(prev_choice == 0) { 
      choice = rbinom(1, 1, rule_following)}
    if(prev_choice == 1) { 
      choice = rbinom(1, 1, (1-rule_following))}
  }
  return(choice)  
}
```


```{r simulation function RA}

sim_vs_random <- function(agents, trials, rule_following){
  
  feedback <- array(NA, c(agents, trials))
  performance_df <- data_frame()
  
  for (agent in 1:agents){
    self <- rep(NA, trials)
    bot <- rep(NA, trials)
  
    self[1] <- random_agent(0.5)
    
    for(trial in seq(trials)) {
      bot[trial] <- random_agent()
    }
    
    for (trial in 2:trials){
      if(self[trial-1] == bot[trial-1]) {
        feedback[agent, trial] = 1
      } 
      else {
        feedback[agent, trial] = 0
      }
      self[trial] <- win_shift_agent(prev_choice = self[trial-1], 
                                      feedback = feedback[agent, trial], 
                                      rule_following = rule_following)
    }
    
    df_temp <- tibble(agent = agent, self, bot, trial = seq(trials), 
                      feedback = as.numeric(self==bot)) %>% 
      mutate(cumulative_self = cumsum(feedback)/seq_along(feedback),
             cumulative_bot = cumsum(1-feedback)/seq_along(feedback)) 
    
    performance_df <- rbind(performance_df, df_temp)
    
  }
  
  return(performance_df)
}
```


```{r simulation and fitting function}

sim_d_and_fit <- function(seed, trials, rule_following) {
  for (t in seq(trials)) {
    temp <-  sim_vs_random(agents = 1,
                           trials = trials, 
                           rule_following = rule_following)
  }
  
  data <-  list(
    trials = trials,
    choice = lead(temp$self, 1),
    self = temp$self,
    other = temp$bot
  )
  
  data$choice[t] <- 0

  samples <- model$sample(
    data = data,
    seed = seed,
    chains = 1,
    parallel_chains = 1,
    threads_per_chain = 1,
    iter_warmup = 1000,
    iter_sampling = 2000,
    refresh = 0,
    max_treedepth = 20,
    adapt_delta = 0.99,
  )

  draws_df <- as_draws_df(samples$draws())
  df <- tibble(rule_followingEst = draws_df$rule_following_posterior,
               rule_following_prior = draws_df$rule_following_prior,
               rule_followingTrue = rule_following,
               prior_preds_LR = draws_df$prior_preds_LR,
               prior_preds_LL = draws_df$prior_preds_LL,
               prior_preds_WR = draws_df$prior_preds_WR,
               prior_preds_WL = draws_df$prior_preds_WL,
               post_preds_LR = draws_df$post_preds_LR,
               post_preds_LL = draws_df$post_preds_LL,
               post_preds_WR = draws_df$post_preds_WR,
               post_preds_WL = draws_df$post_preds_WL)
  
  return(df)
}

```

# FITTING THE MODEL

```{r import model}
## Specify where the model is
file <- file.path("model2.stan")
model <- cmdstan_model(file, 
                     cpp_options = list(stan_threads = TRUE),
                     stanc_options = list("O1")) 


```

```{r}
# fitting a model
test <- sim_d_and_fit(seed = 100, trials = 100, rule_following = .8)
```


# PLOTTING

```{r}
# making recovery_df
pacman::p_load(tidyr, patchwork)
plan(multisession, workers = 4)

# making priors for the param recov
rule_following <- seq(.1, .9, .1)
df <- tibble(rule_following) %>% 
  mutate(seed = 1000, trials = 500) 

recovery_df <- future_pmap_dfr(df, sim_d_and_fit, .options = furrr_options(seed = TRUE))
```

```{r}
# Prior-posterior update
ggplot(test) +
  geom_density(aes(rule_followingEst), fill="blue", alpha=0.3) +
  geom_density(aes(inv.logit(rule_following_prior)), fill="red", alpha=0.3) + # inv.logit bias_win_prior
  xlab("Rule Following") + # Tendency to choose 1 ??
  ylab("Posterior Density") +
  theme_classic() + 
  labs(title = "Prior-posterior Update")+
  coord_cartesian(xlim = c(0,1)) + 
  geom_point(x = unique(test$rule_followingTrue), y = 0, color = "red", shape = 17, size = 5)
```

## parameter recovery
```{r}
ggplot(recovery_df, aes(rule_followingTrue, rule_followingEst)) + 
  geom_point(alpha = 0.1) + 
  geom_smooth( method = "lm") +
  theme_classic() + 
  labs(title = "Param Recov rule_following") + 
  geom_abline(
    slope = 1, 
    intercept = 0,
    color = "red") +
  coord_cartesian(ylim = c(0,1))
```


## prior-posterior predictions
```{r}
# predictions when loosing
p1 <- ggplot(test) + 
  geom_histogram(aes(prior_preds_LL), color="lightblue", fill="blue", alpha=0.3, bins=90) +
  geom_histogram(aes(post_preds_LL), color="darkblue", fill="blue", alpha=0.3, bins=90) +
  #geom_point(x = 0.7*100, y = 0, color = "red", shape = 17, size = 5) +
  xlab("Predicted right (1) choices out of 100 trials") +
  ylab("Density") +
  theme_classic() + 
  labs(title = "Choice after agent chose left (0) and lost") + 
  coord_cartesian(xlim = c(0,100))

p2 <- ggplot(test) + 
  geom_histogram(aes(prior_preds_LR), color="lightblue", fill="blue", alpha=0.3, bins=90) +
  geom_histogram(aes(post_preds_LR), color="darkblue", fill="blue", alpha=0.3, bins=90) +
  #geom_point(x = 0.9*100, y = 0, color = "red", shape = 17, size = 5) +
  xlab("Predicted right (1) choices out of 100 trials") +
  ylab("Density") +
  theme_classic() + 
  labs(title = "Choice after agent chose right (1) and lost") + 
  coord_cartesian(xlim = c(0,100))


# predictions when winning
p3 <- ggplot(test) + 
  geom_histogram(aes(prior_preds_WL), color="lightblue", fill="blue", alpha=0.3, bins=90) +
  geom_histogram(aes(post_preds_WL), color="darkblue", fill="blue", alpha=0.3, bins=90) +
 # geom_point(x = 0.7*100, y = 0, color = "red", shape = 17, size = 5) +
  xlab("Predicted right (1) choices out of 100 trials") +
  ylab("Density") +
  theme_classic() + 
  labs(title = "Choice after agent chose left (0) and won") + 
  coord_cartesian(xlim = c(0,100))

p4 <- ggplot(test) + 
  geom_histogram(aes(prior_preds_WR), color="lightblue", fill="blue", alpha=0.3, bins=90) +
  geom_histogram(aes(post_preds_WR), color="darkblue", fill="blue", alpha=0.3, bins=90) +
 # geom_point(x = 0.7*100, y = 0, color = "red", shape = 17, size = 5) +
  xlab("Predicted right (1) choices out of 100 trials") +
  ylab("Density") +
  theme_classic() + 
  labs(title = "Choice after agent chose right (1) and won") + 
  coord_cartesian(xlim = c(0,100))

ggarrange(p1, p2, p3, p4, common.legend = TRUE)

# ggsave("pp_predict.png", width = 1300, height = 600, units = 'px', dpi = 150)

```

# Prior sensitivity check 

```{r import model}
## Specify where the model is
file2 <- file.path("model2_sens_check.stan")
model <- cmdstan_model(file2, 
                     cpp_options = list(stan_threads = TRUE),
                     stanc_options = list("O1")) 
```

```{r}
prior_mean_RF <- 0
prior_sd_RF <- seq(.1, 1, .1)

priors <-  tibble(
  expand.grid(
    tibble(
      prior_mean_RF, prior_sd_RF)))
```

```{r}
sim_d_and_fit_prior_sensitivity <- function(
    prior_mean_RF, prior_sd_RF) {
    for (t in seq(100)) {
      temp <-  sim_vs_random(agents = 1,
                           trials = 100, 
                           rule_following = .8)
    }
  
    data <-  list(
    trials = 100,
    choice = lead(temp$self, 1),
    self = temp$self,
    other = temp$bot,
    prior_mean_RF = prior_mean_RF,
    prior_sd_RF = prior_sd_RF
  )
  
  data$choice[100] <- 0 # change this!
    
    samples <- model$sample(
      data = data,
      seed = 1000,
      chains = 1,
      parallel_chains = 1,
      threads_per_chain = 1,
      iter_warmup = 1000,
      iter_sampling = 2000,
      refresh = 0,
      max_treedepth = 20,
      adapt_delta = 0.99
      )
    
    draws_df <- as_draws_df(samples$draws())
      temp <- tibble(
                    rule_followingEst = draws_df$rule_following_posterior,
                    rule_following_prior = draws_df$rule_following_prior,
                    rule_followingTrue = draws_df$rule_following,
                    prior_mean_RF = prior_mean_RF,
                    prior_sd_RF = prior_sd_RF,
                    )
                    
  return(temp)
}

```


# fitting the model
```{r}
pacman::p_load(tidyr, patchwork)
plan(multisession, workers = 4)

recovery_df <- future_pmap_dfr(priors, sim_d_and_fit_prior_sensitivity, .options = furrr_options(seed = TRUE))

#write.csv(recovery_df, "recovery_df_sens.csv", row.names = FALSE)
```

## prior sensitivity plot
```{r}
ggplot(recovery_df, aes(prior_sd_RF, rule_followingEst)) +
  geom_point(alpha = 0.1) +
  geom_hline(yintercept = 0.8, color = "red") +
  geom_smooth(method = lm) +
  theme_classic() +
  labs(title = "Prior sensitivity check")
```

#### Cattarpillar plots ####
```{r simulation and fitting function}

sim_d_and_fit <- function(seed, trials, rule_following, clean = T) {
  for (t in seq(trials)) {
    temp <-  sim_vs_random(agents = 1,
                           trials = trials, 
                           rule_following = rule_following)
  }
  
  data <-  list(
    trials = trials,
    choice = lead(temp$self, 1),
    self = temp$self,
    other = temp$bot
  )
  
  data$choice[t] <- 0

  samples <- model$sample(
    data = data,
    seed = seed,
    chains = 1,
    parallel_chains = 1,
    threads_per_chain = 1,
    iter_warmup = 1000,
    iter_sampling = 2000,
    refresh = 0,
    max_treedepth = 20,
    adapt_delta = 0.99,
  )
if(clean == T) {
  draws_df <- as_draws_df(samples$draws())
  df <- tibble(rule_followingEst = draws_df$rule_following_posterior,
               rule_following_prior = draws_df$rule_following_prior,
               rule_followingTrue = rule_following,
               prior_preds_LR = draws_df$prior_preds_LR,
               prior_preds_LL = draws_df$prior_preds_LL,
               prior_preds_WR = draws_df$prior_preds_WR,
               prior_preds_WL = draws_df$prior_preds_WL,
               post_preds_LR = draws_df$post_preds_LR,
               post_preds_LL = draws_df$post_preds_LL,
               post_preds_WR = draws_df$post_preds_WR,
               post_preds_WL = draws_df$post_preds_WL)
  
  return(df)
}
  else if(clean ==F) {
    return(samples)
  }
}

```

# FITTING THE MODEL

```{r import model}
file <- file.path("model2.stan")
model <- cmdstan_model(file, 
                     cpp_options = list(stan_threads = TRUE),
                     stanc_options = list("O1")) 
```

## Sampling issues

```{r check for sampling issues}
#Fit 
samples <- sim_d_and_fit(seed = 1000, trials = 100, rule_following = .8, clean = FALSE)
# Diagnose
samples$cmdstan_diagnose()
# Plot hairy caterpillars
draws_df <- as_draws_df(samples$draws())
ggplot(draws_df, aes(.iteration, rule_following, group = .chain, color=.chain)) + 
  geom_line() +
  labs(title = "Rule_following") +
  theme_classic()

```

